

Contact me[QuickStart]


if you have any problem or question, please send email to iamkaihu@gmail.com

=The problem=
QA reported a bug on Linux platform. you opened the IDE, quickly wrote a test to reproduce it, the test helped you to find the defect in the production code very quickly, It was easy to fix! You ran the test again, it passed in this time, which proved that you really fixed the problem.

You announced you found the problem and fixed it, you were about to checkin the code. But wait, you cannot checkin, because it was purely a Linux related bug, the test will definitely fail on the Windows platform. If you mark the test as @Ignore, maybe some changes in the future will make the bug reopen.

Hang on, How about write the test in this way:

{{{
@Test
public void shouldPassOnLinuxPlatform() {
     boolean isLinuxPlatform = detect the OS;
     if (isLinuxPlatform) {
          run the test.
     }
}

}}}

Problem resolved, everyone is happy. the only imperfect is the test code is a bit ugly.


There are many cases you want to write the test to test for real(rather than mock it), this kind of test give you lot of confidence that you really resolved the problem, but it also bring in the trouble like the tests can only pass if *some prerequisites are satisfied.*

=Solution=  
 
junit-ext is aiming for providing a nice way to run the tests base on the prerequisite.

{{{
@RunWith(PrerequisiteAwareClassRunner.class)
public class TestCasesOnDifferentOS {
    @Test
    @Prerequisite(checker = OSChecker.class, arguments = OSChecker.LINUX)
    public void shouldPassOnLinuxPlatform() throws Exception {
    }
}

}}}

In this way(declared PrerequisiteAwareClassRunner and @Prerequisite annotation), test case will be only executed on linux platform.

=Why not junit assumption=
The purpose is the same, to run some test cases conditionally, from junit java doc, you can find this sample code.
{{{
    // only provides information if database is reachable.
    @Test public void calculateTotalSalary() {
        DBConnection dbc = Database.connect();
        assumeNotNull(dbc);
        // ...
     }
}}}

this test case will firstly be executed, and the lines next to
{{{
    assumeNotNull(dbc);
}}}
will be skipped when dbc is null and the test case will be marked as *passed*.


using @Prerequisite, for the same purpose, the test case will be implemented in this way
{{{
    @Test
    @Prerequisite(checker = DatabaseChecker.class)
    public void calculateTotalSalary() {
        //your code there
    }

    class DatabaseChecker implements Checker {
       public boolean satisify() {
            return Database.connect() != null
       }
    }
}}}

when the conn is null, the test will *not* be executed, and will be marked as *ignored*

the reason I think @Prerequisite is better is:

# A passed test case means the actual result is same as expected, considered the test case is actually not executed, it should be marked as ignored rather than passed. Green bar will hide the problem.

# If the dbc is null which means the the assumption is wrong then the test framework should not waste time on calling the test case.

# The Checker can be reused cross test cases, on the above case, you can easily write another test cases with same assumption in this way.
{{{
    @Test
    @Prerequisite(checker = DatabaseChecker.class)
    public void calculateSomeOneSalary() {
          //your code here
    }
}}}
that is why I wrote OSChecker, FileChecker and etc, so developers do not need to be bothered with writing their own in those cases.

# Good support from IDE, when you type
{{{
    @Prerequisite(checker =
}}}
and press ctrl + alt + space(in IntelliJ), you can get all available Checkers in your classpath.

# More readable

=Checkers=

Checker is used to decide whether the prerequisite is satisfied or not.

There are 2 Checkers provided as default.

* OSChecker 

Check whether the OS is your target platform or not. you can provide your target through arguments

@Prerequisite(checker = OSChecker.class, arguments = *OSChecker.LINUX*)


* FileChecker 

Check whether the targeting file exists or not.

@Prerequisite(checker = FileChecker.class, arguments = */etc/version*)

* HttpChecker 

Check whether the url is reachable or not

@Prerequisite(checker = HTTPChecker.class, arguments = http://www.google.com*)


* AppsInstalledChecker

Check whether the target application is installed on your os or not, you can provide command to detect it, for example, you can detect whether ant is installed by providing "ant help" as the command.

@Prerequisite(checker = AppsInstalledChecker.class, arguments = "ant help"*)

it the process running "ant help" throws exception, that means ant is not installed.





=Write your own Checker=
It is very easy to develop your own Checker, you can develop your own checker by implementing the Checker interface.

{{{
package com.googlecode.junit.ext;

public interface Checker {
    boolean satisfy();
}
}}}


{{{
package com.googlecode.junit.ext;

public class MyChecker implements Checker {
    public boolean satisfy() {
        //to somethin and return boolean.
    }
}}}

and use it in your test case like :

{{{
@Prerequisite(checker = MyChecker.class)
public void runTestWhenMyCheckerIsSatisfied() {

}
}}}


your checker can take String or String[] argument as contructor parameter like,

{{{
package com.googlecode.junit.ext;

public class MyChecker implements Checker {
    public MyChecker(String str) {

    }
 
    public boolean satisfy() {
        //to somethin and return boolean.
    }
}}}


and provide arguments throught argument :

{{{
@Prerequisite(checker = MyChecker.class, arguments="")
public void runTestWhenMyCheckerIsSatisfied() {

}
}}}

or

{{{
@Prerequisite(checker = MyChecker.class, arguments={"", ""})
public void runTestWhenMyCheckerIsSatisfied() {

}
}}}


That is it.


if you have any problem or question, please send email to iamkaihu@gmail.com